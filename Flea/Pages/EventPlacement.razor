@page "/Placing/{EventId}"
@inject IDbContextFactory<BingoContext> _dbFactory

@using Flea.Models
@using Flea.Utility
@using Microsoft.EntityFrameworkCore
@using Table = Flea.Models.Table
@using Cluster = Flea.Models.Cluster

<div class="container">
    @if (_clusters != null)
    {
        <div class="cluster-container">
            @* 2 clusters(2,4) opråber 2 clusters(4,2) *@
            @{
                var top = _clusters.Where(c => 
                    char.IsDigit(c.Name[0]) && int.Parse(c.Name) < 5);
                
                var topMiddle = _clusters.Where(c => 
                    char.IsLetter(c.Name[0]) && c.Name[0] >= 'M' && c.Name[0] <= 'P');
                
                var middle = _clusters.Where(c => 
                    char.IsLetter(c.Name[0]) && c.Name[0] >= 'A' && c.Name[0] <= 'L');

                var bottom = _clusters.Where(c => 
                    char.IsDigit(c.Name[0]) && int.Parse(c.Name) >= 5);
            }
            <div class="clusters upper">
                @{ var i = 0;}
                @foreach (var cluster in top)
                {
                    <Cluster
                        Inner="@cluster"
                        StartNode="@_startNode"
                        Paths="@_paths"
                        SelectedCluster="@_selectedCluster"
                        OnTableSelect="@TableSelected"/>
                    if (i++ == 1){<div class="rando">Oplæser</div>}
                }
            </div>
            <div class="center">
                <div class="clusters middle-top">
                    @foreach(var cluster in topMiddle){
                        <Cluster
                            Inner="@cluster"
                            StartNode="@_startNode"
                            Paths="@_paths"
                            SelectedCluster="@_selectedCluster"
                            OnTableSelect="@TableSelected"/>
                    }
                </div>
                <div class="clusters middle">
                    @foreach(var cluster in middle){
                        <Cluster
                            Inner="@cluster"
                            StartNode="@_startNode"
                            Paths="@_paths"
                            SelectedCluster="@_selectedCluster"
                            OnTableSelect="@TableSelected"/>
                    }
                </div>
                @* 3 clusters(4,3,3) *@
                <div class="clusters lower">
                    @foreach(var cluster in bottom){
                        <Cluster
                            Inner="@cluster"
                            StartNode="@_startNode"
                            Paths="@_paths"
                            SelectedCluster="@_selectedCluster"
                            OnTableSelect="@TableSelected"/>
                    }
                </div>
                @* tilgængelig, reseveret, start node, mulig sti *@
                <div class="guide"></div>
            </div>
        </div>
        <div class="side-panel">
            @if (_shownReservation != null)
            {
                <h3>@_shownReservation?.ReservationOwner.Name</h3>
                <h3>@_shownReservation?.ReservationOwner.PhoneNumber</h3>
                <h4>Table count: @_shownReservation?.TableCount</h4>
                if (_shownReservation != _selectedReservation)
                {
                    foreach (var table in _shownReservation?.Tables!)
                    {
                        <p>@table.Id</p>
                    }
                    <button class="del-button" @onclick="DeleteReservation">Unassign Reservation</button>
                }
            }
        </div>
    }
    else
    {
        <p>Loading Event</p>
    }
</div>

<style>
    .container {
        display: grid;
        grid-template-columns: max-content max-content;
        grid-column-gap: 25px;
    }
    .clusters.middle-top {
        grid-template-columns: repeat(4, max-content);
        grid-auto-flow: row;
        row-gap: 13px;
        column-gap: 28px;
    }
    .clusters.middle {
        grid-template-rows: repeat(3, max-content);
        grid-auto-flow: column;
    }
    .clusters.upper {
        grid-template-columns: repeat(5, max-content);
        grid-auto-flow: row;
        column-gap: 25px;
        row-gap: 13px;
    }
    .clusters.lower {
        grid-template-columns: repeat(3, max-content);
        grid-auto-flow: row;
    }
    .clusters{
        display: grid;
        width: fit-content;
        row-gap: 25px;
        column-gap: 25px;
        margin-bottom: 25px;
    }
    .side-panel {
      height: 100%;
      float: left;
      width: min-content;
      transition: 4s;
    }
    .side-panel.off {
        width: 0;
    }
    .table {
        display: flex;
        align-items: center;
        justify-content: center;
        border: 1px solid black;
    }
    .table.vertical {
        width: 50px;
        height: 25px;
    }
    .table.horizontal {
        width: 25px;
        height: 50px;
    }
    .table.bottom {
        margin-top: 25px;
    }
    .table.on {
        background-color: gray;
    }
    .table.off {
        background-color: white;
        color: black;
    }
    .table.path {
        background-color: yellow;
    }
    .table.start {
        background-color: #00ff00;
    }
    .cluster {
        position: relative;
        display: grid;
        width: max-content;
        grid-template-columns: repeat(4, max-content);
        row-gap: 13px; /* 12.5 */
    }
    .cluster-tag {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
</style>

@code {
    [Parameter]
    public string EventId { get; set; }

    private Event? _event;
    private List<Cluster>? _clusters { get; set; }
    private Reservation? _selectedReservation { get; set; }
    private Reservation? _shownReservation { get; set; }
    private Table? _startNode { get; set; }
    private List<int[]> _paths { get; set; }
    private Cluster _selectedCluster { get; set; }
    
    private async void TableSelected((Table, Cluster, int) id)
    {
        var (table, cluster, pathId) = id;
        _shownReservation = table.Reservation ?? _selectedReservation;
        if (table.Reservation != null)
        {
            _startNode = null;
            _paths.Clear();
            return;
        }
        if (_selectedReservation == null)
        {
            Console.WriteLine("[Error Popup] No reservation has been selected");
            return;
        }
        if (_clusters != null && !_clusters.Contains(cluster))
        {
            Console.WriteLine("[Error Popup] The selected cluster does not exist!");
            return;
        }
        _selectedCluster = cluster;

        if (!_selectedCluster.Tables.Contains(table))
        {
            Console.WriteLine("The selected table does not exists");
            return;
        }
        
        if (pathId != -1)
        {
            await ConfirmSelection(pathId);
            _selectedReservation = null;
            _startNode = null;
            _paths.Clear();
            StateHasChanged();
            return;
        }
        
        Console.WriteLine($"TableId: {table.Id} ClusterId: {cluster.Id} PathId: {pathId}");
        _paths.Clear();
        if (table == _startNode)
        {
            _startNode = null;
            return;
        }
        _startNode = null;
        var offset = _selectedCluster.Tables.IndexOf(table);
        var endNode1 = SelectedPaths(_selectedCluster, offset, 1);
        if (endNode1 != null)
        {
            _paths.Add(endNode1);
            _startNode = table;
        }
        if (_selectedCluster.Type != ClusterType.Round)
        {
            if (endNode1 == null)
                Console.WriteLine("[Error Popup] Unable to create a path using the selected start node");
            return;
        }
        var endNode2 = SelectedPaths(_selectedCluster, offset, -1);
        if (endNode2 == null)
        {
            if (endNode1 == null)
                Console.WriteLine("[Error Popup] Unable to create any paths using the selected start node");
            return;
        }
        _paths.Add(endNode2);
        _startNode = table;
    }

    private async Task ConfirmSelection(int pathId)
    {
        Console.WriteLine("Confirm Selection");
        for (var i = 0; i < _selectedReservation?.TableCount; i++)
        {
            var table = _selectedCluster.Tables.Find(t => t.Id == _paths[pathId][i]);
            if (table == null) continue;
            table.Reservation = _selectedReservation;
            await _dbFactory.Save(table);
        }
    }

    private async void DeleteReservation()
    {
        if (_shownReservation == null) return;
        Console.WriteLine("Delete Reservation");
        await using var context = _dbFactory.CreateDbContext();
        foreach (var table in _shownReservation.Tables)
        {
            table.Reservation = null;
            context.Tables.Update(table);
        }
        _shownReservation.Tables.Clear();
        context.Reservations.Update(_shownReservation);
        await context.SaveChangesAsync();
        _shownReservation = null;
        StateHasChanged();
    }
    private int[]? SelectedPaths(Cluster cluster,  int offset, int direction)
    {
        if (_selectedReservation == null) return null;
        var ids = new int[_selectedReservation.TableCount];
        for (var i = 0; i < _selectedReservation.TableCount; i++)
        {
            if (cluster.Tables[offset].Reservation != null) return null;
            
            ids[i] = cluster.Tables[offset].Id;
            if (cluster.Type == ClusterType.Round)
                (offset, direction) = Wrap(offset, direction);
            offset += direction;
            
            if (offset >= cluster.Tables.Count && i != cluster.Tables.Count-1)
            {
                return null;
            }
        }
        return ids;
    }

    private static (int, int) Wrap(int offset, int direction)
    {
        return offset switch
        {
            7 when direction is 1 => (4, -1),
            4 when direction is -1 => (-1, 1),
            0 when direction is -1 => (3, 1),
            3 when direction is 1 => (8, -1),
            _ => (offset, direction)
        };
    }

    private async Task<Event?> GetEvent()
    {
        await using var context = _dbFactory.CreateDbContext();
        return  await context.Events
            .Include(e => e.Clusters)
            .ThenInclude(c=> c.Tables)
            .ThenInclude(t => t.Reservation)
            .ThenInclude(r => r!.ReservationOwner)
            .AsSplitQuery()
            .OrderBy(e=> e.Id)
            .FirstOrDefaultAsync(e => e.Id == int.Parse(EventId));
    }
    
    protected override async Task OnInitializedAsync()
    {
        _event = await GetEvent();
        if (_event != null)
        {
            _event.Clusters.Sort((a, b) => a.Name[0] - b.Name[0]);
            _event.Clusters.Reverse();
            foreach (var cluster in _event.Clusters)
            {
                cluster.Tables.Sort((a,b) => a.Id - b.Id);
            }
            _clusters = _event.Clusters;
        } else
            await _dbFactory.Save(new Event("Crazy event", DateTime.Now)); // Todo: Remove when out of test phase
        await base.OnInitializedAsync();
    }

    protected override void OnInitialized()
    {
        // Db Integration get the selected Event 
        // Get the clusters and find a sane way to place them all :c
        _selectedReservation = new Reservation(1, 4, true, ""){ReservationOwner = new Customer("Loke Walsted", "1007823")};
        _paths = new List<int[]>();
        _startNode = null;
    }

}
